<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>UFS Structure Logger (Manual Entry + Voice + Export + Track)</title>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- toGeoJSON (KML -> GeoJSON) -->
  <script src="https://unpkg.com/@tmcw/togeojson@5.6.1/dist/togeojson.umd.js"></script>

  <!-- Turf (point-in-polygon) -->
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>

  <!-- JSZip (ZIP -> extract KMLs in browser) -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

  <style>
    :root{
      --bg:#0b1220;
      --panel:#0f172a;
      --border:#22304a;
      --text:#e5e7eb;
      --muted:#94a3b8;
      --accent:#38bdf8;
      --ok:#22c55e;
      --bad:#ef4444;
      --warn:#f59e0b;
      --radius:16px;
      --shadow: 0 18px 70px rgba(0,0,0,.55);
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color:var(--text);
      background:
        radial-gradient(900px 420px at 15% 10%, rgba(56,189,248,.14), transparent 60%),
        radial-gradient(900px 420px at 85% 20%, rgba(167,139,250,.10), transparent 60%),
        radial-gradient(700px 400px at 35% 85%, rgba(34,197,94,.10), transparent 55%),
        var(--bg);
    }
    .wrap{ width:min(1100px, 100%); margin:14px auto 30px; padding:0 12px; }
    .header{
      background: linear-gradient(180deg, rgba(15,23,42,.92), rgba(11,19,38,.92));
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 14px 14px 12px;
    }
    .title{ display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:8px; flex-wrap:wrap; }
    .title h1{ margin:0; font-size:18px; letter-spacing:.2px; line-height:1.25; }
    .badge{
      padding:6px 10px;
      border:1px solid var(--border);
      background: rgba(56,189,248,.10);
      color: var(--text);
      border-radius: 999px;
      font-weight: 900;
      font-size: 12px;
      white-space: nowrap;
    }
    .sub{ color: var(--muted); font-size: 12px; line-height: 1.45; }
    .nav{ margin-top:10px; display:flex; gap:10px; flex-wrap:wrap; }
    .linkBtn{
      text-decoration:none;
      display:inline-flex; align-items:center; gap:8px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.05);
      color: var(--text);
      padding: 9px 12px;
      border-radius: 12px;
      font-weight: 900;
    }

    .grid{ display:grid; grid-template-columns:1fr; gap:12px; margin-top:12px; }
    .card{
      background: linear-gradient(180deg, rgba(15,23,42,.92), rgba(11,19,38,.92));
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .cardHead{
      padding: 12px 12px 10px;
      border-bottom:1px solid rgba(34,48,74,.7);
      display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap;
    }
    .cardHead .h{ font-weight: 900; font-size: 14px; display:flex; align-items:center; gap:8px; }
    .cardBody{ padding: 12px; }
    .row{ display:grid; grid-template-columns:1fr; gap:10px; }
    .controls{ display:flex; flex-wrap:wrap; gap:10px; align-items:center; }

    .btn{
      border:1px solid rgba(255,255,255,.08);
      background: rgba(255,255,255,.06);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 12px;
      font-weight: 900;
      cursor:pointer;
      transition: transform .06s ease, background .15s ease;
      user-select:none;
    }
    .btn:active{ transform: translateY(1px); }
    .btn.primary{
      background: linear-gradient(180deg, rgba(56,189,248,.22), rgba(56,189,248,.12));
      border-color: rgba(56,189,248,.30);
    }
    .btn.ok{
      background: linear-gradient(180deg, rgba(34,197,94,.22), rgba(34,197,94,.12));
      border-color: rgba(34,197,94,.30);
    }
    .btn.bad{
      background: linear-gradient(180deg, rgba(239,68,68,.22), rgba(239,68,68,.12));
      border-color: rgba(239,68,68,.30);
    }
    .btn.warn{
      background: linear-gradient(180deg, rgba(245,158,11,.22), rgba(245,158,11,.12));
      border-color: rgba(245,158,11,.35);
    }

    .inp, .sel{
      width:100%;
      padding: 11px 12px;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.05);
      color: var(--text);
      outline:none;
      font-weight: 800;
    }
    .inp:focus, .sel:focus{
      border-color: rgba(56,189,248,.45);
      box-shadow: 0 0 0 4px rgba(56,189,248,.14);
    }
    textarea.inp{ resize: vertical; min-height: 84px; }

    .two{ display:grid; grid-template-columns:1fr; gap:12px; }
    @media (min-width: 920px){ .two{ grid-template-columns: 1.1fr .9fr; } }

    #map{
      width:100%;
      height: 420px;
      border-radius: 16px;
      border:1px solid var(--border);
      overflow:hidden;
      background: #0b1220;
    }

    .kpi{ display:grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .kpi .box{
      border:1px solid rgba(255,255,255,.08);
      background: rgba(255,255,255,.05);
      border-radius: 14px;
      padding: 10px 10px;
      min-height: 52px;
    }
    .kpi .lab{ color: var(--muted); font-size: 11px; font-weight: 900; }
    .kpi .val{ font-weight: 900; font-size: 13px; margin-top: 4px; word-break: break-word; }

    .hint{ color: var(--muted); font-size: 11px; margin-top: 8px; line-height: 1.35; }
    .fileRow{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    input[type="file"]{ display:none; }
    .pill{
      padding:7px 10px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.05);
      font-weight: 900;
      font-size: 12px;
    }
    .chk{
      display:flex; align-items:center; gap:8px;
      padding: 8px 10px;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,.08);
      background: rgba(255,255,255,.04);
      font-weight: 900;
      color: var(--text);
      user-select:none;
    }
    .chk input{ transform: scale(1.1); }
    .selGrid{ display:grid; grid-template-columns:1fr; gap:10px; }
    @media (min-width: 720px){ .selGrid{ grid-template-columns: 1fr 1fr; } }
    code{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="header">
      <div class="title">
        <h1>UFS Structure Logger (Manual Entry + Voice + Export + Track)</h1>
        <div class="badge" id="countBadge">0 boundaries</div>
      </div>
      <div class="sub">
        ‚úÖ Load Boundary + KML first ‚Üí Start GPS ‚Üí Fill details ‚Üí Save Structure (pin drops at GPS point).<br/>
        ‚úÖ KML name must be: <b>b{block}_w{ward}_iv{iv}_xxxx.kml</b>
      </div>
      <div class="nav">
        <a class="linkBtn" href="block_finder.html">üß≠ Open Block Finder</a>
      </div>
    </div>

    <div class="grid">
      <!-- Controls -->
      <div class="card">
        <div class="cardHead">
          <div class="h">‚öôÔ∏è Controls</div>
          <div class="fileRow">
            <label class="btn primary" for="kmlInput">Upload .kml / .zip</label>
            <input id="kmlInput" type="file" accept=".kml,.zip" multiple />
            <label class="btn" for="boundaryInput">Upload Boundary CSV</label>
            <input id="boundaryInput" type="file" accept=".csv,.txt" />
          </div>
        </div>

        <div class="cardBody">
          <div class="row">
            <input class="inp" id="proxyUrl" placeholder="Apps Script Proxy URL (needed only for Drive ZIP)" />
            <input class="inp" id="kmlUrl" placeholder="Drive ZIP link OR normal URL (.kml/.zip)" />

            <div class="controls">
              <button class="btn ok" id="fetchDriveBtn">Fetch ZIP from Drive</button>
              <button class="btn primary" id="loadKmlUrlBtn">Load URL (non-Drive)</button>
              <button class="btn" id="restoreSavedBtn">Restore Saved KML</button>
              <button class="btn warn" id="clearSavedBtn">Clear Saved KML</button>
              <label class="chk"><input type="checkbox" id="saveOfflineChk" checked>Save Offline</label>
              <label class="chk"><input type="checkbox" id="autoFetchChk">Auto-fetch Drive ZIP on open</label>
            </div>

            <input class="inp" id="boundaryUrl" placeholder="Boundary CSV URL (GitHub raw / public link) OR Google Sheet link" />
            <div class="controls">
              <button class="btn warn" id="loadBoundaryBtn">Load Boundary (URL/Sheet)</button>
              <button class="btn ok" id="startGpsBtn">Start GPS</button>
              <button class="btn bad" id="stopGpsBtn">Stop</button>
              <button class="btn primary" id="toggleTrackBtn">üß≠ Start Track</button>
              <button class="btn" id="fitAllBtn">Fit All</button>
              <button class="btn" id="clearBtn">Clear Map</button>
            </div>
          </div>
        </div>
      </div>

      <!-- Structure Logger -->
      <div class="card">
        <div class="cardHead">
          <div class="h">üè† Structure Logger</div>
          <div class="pill" id="logStatus">Logs: 0</div>
        </div>

        <div class="cardBody">
          <div class="selGrid">
            <input class="inp" id="houseNoInp" placeholder="House No / Plot No" />
            <input class="inp" id="structureNameInp" placeholder="Structure Name (Shop/School/Temple etc.)" />
            <input class="inp" id="ownerNameInp" placeholder="Owner Name" />
            <input class="inp" id="householdsInp" placeholder="No of Household (e.g., 1/2/3)" inputmode="numeric" />
          </div>

          <div style="margin-top:10px">
            <textarea class="inp" id="remarksInp" rows="3" placeholder="Remarks / Landmark / Any note (optional)"></textarea>
          </div>

          <div class="controls" style="margin-top:10px">
            <button class="btn ok" id="addStructureBtn">üìå Save Structure at Current Location</button>
            <button class="btn" id="voiceBtn">üéôÔ∏è Voice Input (focused field)</button>
            <button class="btn warn" id="stopVoiceBtn">‚èπ Stop Voice</button>
            <button class="btn" id="clearLogsBtn">üßπ Clear Logs</button>
          </div>

          <div class="controls" style="margin-top:10px">
            <button class="btn primary" id="exportCsvBtn">‚¨áÔ∏è Export CSV</button>
            <button class="btn primary" id="exportGeoJsonBtn">‚¨áÔ∏è Export GeoJSON</button>
          </div>

          <div class="hint">
            ‚úÖ Auto IV/Ward/Block is taken from the KML boundary you are inside.<br/>
            ‚úÖ Town is resolved from Boundary CSV/Sheet if it matches, else blank.
          </div>
        </div>
      </div>

      <div class="two">
        <!-- Map -->
        <div class="card">
          <div class="cardHead">
            <div class="h">üó∫Ô∏è Map</div>
            <div class="pill" id="gpsStatus">GPS: OFF</div>
          </div>
          <div class="cardBody">
            <div id="map"></div>
          </div>
        </div>

        <!-- Current detected -->
        <div class="card">
          <div class="cardHead">
            <div class="h">üìç Current Auto-Detected</div>
            <div class="pill" id="boundaryStatus">Boundary: NOT LOADED</div>
          </div>
          <div class="cardBody">
            <div class="kpi">
              <div class="box">
                <div class="lab">Current Location</div>
                <div class="val" id="locVal">‚Äî</div>
              </div>
              <div class="box">
                <div class="lab">Inside KML</div>
                <div class="val" id="insideVal">‚Äî</div>
              </div>
              <div class="box">
                <div class="lab">Auto IV / Ward / Block</div>
                <div class="val" id="iwbVal">‚Äî</div>
              </div>
              <div class="box">
                <div class="lab">Town (resolved)</div>
                <div class="val" id="townVal">‚Äî</div>
              </div>
            </div>
            <div class="hint">Tip: Start GPS + ensure KML boundaries are loaded.</div>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
/* =========================
   Small logger
========================= */
function toast(msg){ console.log(msg); }

/* =========================
   IndexedDB (shared with Block Finder)
========================= */
const DB_NAME = "ufs_kml_viewer_db";
const STORE = "kml_files";
function openDB(){
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if(!db.objectStoreNames.contains(STORE)){
        db.createObjectStore(STORE, { keyPath: "name" });
      }
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}
async function idbPutKml(name, text){
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, "readwrite");
    tx.objectStore(STORE).put({ name, text, savedAt: Date.now() });
    tx.oncomplete = () => resolve(true);
    tx.onerror = () => reject(tx.error);
  });
}
async function idbGetAllKml(){
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, "readonly");
    const req = tx.objectStore(STORE).getAll();
    req.onsuccess = () => resolve(req.result || []);
    req.onerror = () => reject(req.error);
  });
}
async function idbClearAll(){
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, "readwrite");
    tx.objectStore(STORE).clear();
    tx.oncomplete = () => resolve(true);
    tx.onerror = () => reject(tx.error);
  });
}

/* =========================
   CSV parser + boundary maps
========================= */
function parseCSV(text){
  const rows = [];
  let row = [];
  let cur = "";
  let inQuotes = false;
  for(let i=0;i<text.length;i++){
    const ch = text[i];
    const next = text[i+1];
    if(ch === '"'){
      if(inQuotes && next === '"'){ cur += '"'; i++; }
      else inQuotes = !inQuotes;
    }else if(ch === ',' && !inQuotes){
      row.push(cur.trim()); cur = "";
    }else if((ch === '\n' || ch === '\r') && !inQuotes){
      if(ch === '\r' && next === '\n') i++;
      row.push(cur.trim()); cur = "";
      if(row.length > 1 || (row.length===1 && row[0]!== "")){
        rows.push(row.map(x => x.replace(/^"|"$/g,"")));
      }
      row = [];
    }else cur += ch;
  }
  if(cur.length || row.length){
    row.push(cur.trim());
    if(row.length) rows.push(row.map(x => x.replace(/^"|"$/g,"")));
  }
  return rows.filter(r => r.some(c => String(c||"").trim()!==""));
}
const norm = s => String(s||"").trim();
const numOnly = v => String(v||"").replace(/\D/g,"");

let boundaryLoaded = false;
let boundaryExact = new Map();
let boundaryIndexWBIV = new Map();

const makeKey = (town, iv, ward, block) =>
  `${String(town||"").trim().toLowerCase()}|iv${numOnly(iv)}|w${numOnly(ward)}|b${numOnly(block)}`;
const makeKeyWBIV = (iv, ward, block) =>
  `iv${numOnly(iv)}|w${numOnly(ward)}|b${numOnly(block)}`;

function setBoundaryStatus(ok, label){
  const el = document.getElementById("boundaryStatus");
  el.textContent = label;
  el.style.borderColor = ok ? "rgba(34,197,94,.35)" : "rgba(239,68,68,.35)";
  el.style.background  = ok ? "rgba(34,197,94,.10)" : "rgba(239,68,68,.08)";
}
function findHeaderIndex(headers, wanted){
  const low = headers.map(h => String(h||"").toLowerCase().trim());
  for(const cand of wanted){
    const idx = low.indexOf(String(cand).toLowerCase());
    if(idx !== -1) return idx;
  }
  return -1;
}
function loadBoundaryFromCSVText(csvText){
  const rows = parseCSV(csvText);
  if(!rows.length){ setBoundaryStatus(false, "Boundary: EMPTY"); return; }

  const headers = rows[0].map(h => String(h||"").trim());
  const idx = {
    town: findHeaderIndex(headers, ["Town Name","Town","TOWN NAME","TOWN"]),
    north: findHeaderIndex(headers, ["North","NORTH"]),
    east:  findHeaderIndex(headers, ["East","EAST"]),
    south: findHeaderIndex(headers, ["South","SOUTH"]),
    west:  findHeaderIndex(headers, ["West","WEST"]),
    iv:    findHeaderIndex(headers, ["IV Unit Number","IV No","IV","IV UNIT NUMBER"]),
    ward:  findHeaderIndex(headers, ["Ward No","WARD NO","Ward"]),
    block: findHeaderIndex(headers, ["Block Number","BLOCK NUMBER","Block"]),
  };
  const required = ["town","north","east","south","west","iv","ward","block"];
  const missing = required.filter(k => idx[k] === -1);
  if(missing.length){ setBoundaryStatus(false, "Boundary: WRONG HEADERS"); return; }

  boundaryExact = new Map();
  boundaryIndexWBIV = new Map();

  for(let i=1;i<rows.length;i++){
    const r = rows[i];
    const town = norm(r[idx.town]);
    const north = norm(r[idx.north]);
    const east  = norm(r[idx.east]);
    const south = norm(r[idx.south]);
    const west  = norm(r[idx.west]);
    const iv    = norm(r[idx.iv]);
    const ward  = numOnly(r[idx.ward]);
    const block = numOnly(r[idx.block]);
    if(!town || !iv || !ward || !block) continue;

    const item = { town, iv, ward, block, north, east, south, west };
    boundaryExact.set(makeKey(town, iv, ward, block), item);

    const keyWBIV = makeKeyWBIV(iv, ward, block);
    if(!boundaryIndexWBIV.has(keyWBIV)) boundaryIndexWBIV.set(keyWBIV, []);
    boundaryIndexWBIV.get(keyWBIV).push(item);
  }

  boundaryLoaded = true;
  setBoundaryStatus(true, "Boundary: LOADED (" + boundaryExact.size + ")");
}

function sheetIdFromUrl(u){
  const m = String(u||"").match(/\/spreadsheets\/d\/([a-zA-Z0-9-_]+)/);
  return m ? m[1] : null;
}
async function loadBoundaryFromUrlOrSheet(){
  const u = document.getElementById("boundaryUrl").value.trim();
  if(!u) return;

  const sid = sheetIdFromUrl(u);
  let fetchUrl = u;
  if(sid) fetchUrl = `https://docs.google.com/spreadsheets/d/${sid}/export?format=csv&gid=0`;

  let text = "";
  try{
    const res = await fetch(fetchUrl);
    text = await res.text();
  }catch(e){
    setBoundaryStatus(false, "Boundary: LOAD FAILED");
    return;
  }
  if(text.trim().startsWith("<!DOCTYPE html") || text.includes("ServiceLogin")){
    setBoundaryStatus(false, "Boundary: NOT PUBLIC");
    return;
  }
  loadBoundaryFromCSVText(text);
}

function resolveTownForWBIV(iv, ward, block){
  const hits = boundaryIndexWBIV.get(makeKeyWBIV(iv, ward, block)) || [];
  if(hits.length === 1) return hits[0].town;
  return ""; // ambiguous or none
}

/* =========================
   Map init
========================= */
const map = L.map("map", { zoomControl:true }).setView([31.1048, 77.1734], 13);
L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
  maxZoom: 20,
  attribution: "&copy; OpenStreetMap"
}).addTo(map);

const boundaryLayer = L.featureGroup().addTo(map);
const structureLayer = L.featureGroup().addTo(map);

let gpsMarker = null;
let gpsAccuracy = null;
let watchId = null;
let lastPos = null;

/* Track */
let trackOn = false;
let trackLine = null;
let trackPts = [];

function setText(id, v){ document.getElementById(id).textContent = v; }
function setGpsStatus(on){
  const el = document.getElementById("gpsStatus");
  el.textContent = on ? "GPS: ON" : "GPS: OFF";
  el.style.borderColor = on ? "rgba(34,197,94,.35)" : "rgba(239,68,68,.35)";
  el.style.background  = on ? "rgba(34,197,94,.10)" : "rgba(239,68,68,.08)";
}

/* =========================
   KML store + parsing
========================= */
const kmlItems = [];
function updateCount(){ document.getElementById("countBadge").textContent = `${kmlItems.length} boundaries`; }

function parseB_W_IV_FromName(filename){
  const raw  = String(filename || "");
  const base = raw.split("::").pop().split("/").pop().toLowerCase();
  const m = base.match(/^b(\d+)_w(\d+)_iv(\d+)(?:_[^.]*)?\.kml$/i);
  if(!m) return { block:"", ward:"", iv:"", base };
  return { block:m[1], ward:m[2], iv:m[3], base };
}
function geojsonToTurfPolygons(geojson){
  const polys = [];
  if(!geojson || !geojson.features) return polys;
  for(const f of geojson.features){
    if(!f || !f.geometry) continue;
    const g = f.geometry;
    if(g.type === "Polygon" || g.type === "MultiPolygon") polys.push(f);
  }
  return polys;
}
function computeBBoxFromGeoJSON(geojson){
  let N=-Infinity, S=Infinity, E=-Infinity, W=Infinity;
  function walkCoords(coords){
    if(typeof coords[0] === "number"){
      const lon = coords[0], lat = coords[1];
      if(lat > N) N = lat;
      if(lat < S) S = lat;
      if(lon > E) E = lon;
      if(lon < W) W = lon;
      return;
    }
    for(const c of coords) walkCoords(c);
  }
  if(geojson && geojson.features){
    for(const f of geojson.features){
      if(f.geometry && f.geometry.coordinates) walkCoords(f.geometry.coordinates);
    }
  }
  if(!isFinite(N)) return null;
  return {N,S,E,W};
}

async function addKmlFromText(name, text, saveOffline=true){
  const parsed = parseB_W_IV_FromName(name);
  if(!parsed.block || !parsed.ward || !parsed.iv) return;

  const ward = parsed.ward, block = parsed.block, iv = parsed.iv;

  const xml = new DOMParser().parseFromString(text, "text/xml");
  const geojson = toGeoJSON.kml(xml);

  const layer = L.geoJSON(geojson, { style: { weight: 2, opacity: 0.9, fillOpacity: 0.12 } });
  layer.addTo(boundaryLayer);

  const bbox = computeBBoxFromGeoJSON(geojson);
  const polygons = geojsonToTurfPolygons(geojson);

  kmlItems.push({ name, ward, block, iv, layer, geojson, bbox, polygons });
  updateCount();

  if(saveOffline) await idbPutKml(name, text);
}

async function handleKmlOrZipFiles(files){
  if(!files || !files.length) return;
  const saveOffline = document.getElementById("saveOfflineChk").checked;

  for(const file of files){
    const fname = (file.name || "").toLowerCase();
    if(fname.endsWith(".kml")){
      const text = await file.text();
      await addKmlFromText(file.name, text, saveOffline);
      continue;
    }
    if(fname.endsWith(".zip")){
      const zipData = await file.arrayBuffer();
      const zip = await JSZip.loadAsync(zipData);
      const entries = Object.keys(zip.files);
      const kmlEntryNames = entries.filter(n => n.toLowerCase().endsWith(".kml") && !zip.files[n].dir);
      for(const entryName of kmlEntryNames){
        const kmlText = await zip.files[entryName].async("text");
        const virtualName = `${file.name}::${entryName}`;
        await addKmlFromText(virtualName, kmlText, saveOffline);
      }
      continue;
    }
  }
  fitAll();
}

async function restoreSaved(){
  const saved = await idbGetAllKml();
  for(const f of saved){
    if(kmlItems.some(x => x.name === f.name)) continue;
    await addKmlFromText(f.name, f.text, false);
  }
  fitAll();
}
async function clearSaved(){ await idbClearAll(); }

/* =========================
   Drive proxy fetch
========================= */
function extractDriveFileId(url){
  const u = String(url||"");
  let m = u.match(/\/file\/d\/([a-zA-Z0-9_-]+)/);
  if(m) return m[1];
  m = u.match(/[?&]id=([a-zA-Z0-9_-]+)/);
  if(m) return m[1];
  return null;
}
function base64ToU8(b64){
  const bin = atob(b64);
  const u8 = new Uint8Array(bin.length);
  for(let i=0;i<bin.length;i++) u8[i] = bin.charCodeAt(i);
  return u8;
}
async function fetchFromDriveViaProxy(fileId){
  const proxy = document.getElementById("proxyUrl").value.trim();
  if(!proxy) return null;
  const url = `${proxy}?id=${encodeURIComponent(fileId)}`;
  const res = await fetch(url);
  const data = await res.json();
  if(!data.ok) return null;
  return data;
}
async function fetchDriveZip(){
  const link = document.getElementById("kmlUrl").value.trim();
  const fid = extractDriveFileId(link);
  if(!fid) return;

  const saveOffline = document.getElementById("saveOfflineChk").checked;
  const data = await fetchFromDriveViaProxy(fid);
  if(!data) return;

  const name = data.name || `drive_${fid}.zip`;
  const u8 = base64ToU8(data.base64 || "");
  const zip = await JSZip.loadAsync(u8);

  const entries = Object.keys(zip.files);
  const kmlEntryNames = entries.filter(n => n.toLowerCase().endsWith(".kml") && !zip.files[n].dir);
  for(const entryName of kmlEntryNames){
    const kmlText = await zip.files[entryName].async("text");
    const virtualName = `${name}::${entryName}`;
    await addKmlFromText(virtualName, kmlText, saveOffline);
  }
  fitAll();
}
function looksLikeZip(u8){ return u8 && u8.length >= 2 && u8[0] === 0x50 && u8[1] === 0x4B; }
async function loadNonDriveUrl(){
  const input = document.getElementById("kmlUrl").value.trim();
  if(!input) return;
  const saveOffline = document.getElementById("saveOfflineChk").checked;

  const res = await fetch(input);
  const buf = await res.arrayBuffer();
  const u8 = new Uint8Array(buf);

  const name = (new URL(input)).pathname.split("/").pop() || "remote_file";
  if(looksLikeZip(u8) || name.toLowerCase().endsWith(".zip")){
    const zip = await JSZip.loadAsync(u8);
    const entries = Object.keys(zip.files);
    const kmlEntryNames = entries.filter(n => n.toLowerCase().endsWith(".kml") && !zip.files[n].dir);
    for(const entryName of kmlEntryNames){
      const kmlText = await zip.files[entryName].async("text");
      const virtualName = `${name}::${entryName}`;
      await addKmlFromText(virtualName, kmlText, saveOffline);
    }
    fitAll();
    return;
  }
  const text = new TextDecoder("utf-8").decode(u8);
  await addKmlFromText(name.endsWith(".kml") ? name : (name + ".kml"), text, saveOffline);
  fitAll();
}

/* =========================
   Find KML hit for GPS point
========================= */
function findKmlHitForLatLng(lat, lng){
  if(!kmlItems.length) return null;
  const pt = turf.point([lng, lat]);
  for(const item of kmlItems){
    if(!item.bbox) continue;
    if(lat > item.bbox.N || lat < item.bbox.S || lng > item.bbox.E || lng < item.bbox.W) continue;
    for(const f of item.polygons){
      try{
        if(turf.booleanPointInPolygon(pt, f)) return item;
      }catch(e){}
    }
  }
  return null;
}

/* =========================
   Track helper
========================= */
function onTrackPoint(lat, lng, acc){
  if(!trackOn) return;
  const last = trackPts[trackPts.length - 1];
  if(last){
    const d = map.distance([last.lat,last.lng], [lat,lng]);
    if(d < 3) return;
  }
  trackPts.push({lat, lng, ts: Date.now(), acc: acc || null});
  if(!trackLine) trackLine = L.polyline([[lat,lng]]).addTo(map);
  else trackLine.addLatLng([lat,lng]);
}
function toggleTrack(){
  trackOn = !trackOn;
  document.getElementById("toggleTrackBtn").textContent = trackOn ? "üß≠ Stop Track" : "üß≠ Start Track";
}

/* =========================
   GPS start/stop
========================= */
function startGPS(){
  if(!navigator.geolocation) return;
  if(watchId) return;

  watchId = navigator.geolocation.watchPosition(
    (pos) => {
      const { latitude, longitude, accuracy } = pos.coords;
      lastPos = { lat: latitude, lng: longitude, acc: accuracy };

      if(!gpsMarker) gpsMarker = L.circleMarker([latitude, longitude], { radius: 8 }).addTo(map);
      else gpsMarker.setLatLng([latitude, longitude]);

      if(!gpsAccuracy) gpsAccuracy = L.circle([latitude, longitude], { radius: accuracy }).addTo(map);
      else { gpsAccuracy.setLatLng([latitude, longitude]); gpsAccuracy.setRadius(accuracy); }

      setText("locVal", `${latitude.toFixed(6)}, ${longitude.toFixed(6)} (¬±${Math.round(accuracy)}m)`);

      const hit = findKmlHitForLatLng(latitude, longitude);
      if(hit){
        setText("insideVal", hit.name);
        setText("iwbVal", `IV ${hit.iv} / Ward ${hit.ward} / Block ${hit.block}`);
        if(boundaryLoaded){
          const t = resolveTownForWBIV(hit.iv, hit.ward, hit.block);
          setText("townVal", t || "‚Äî");
        }
      }else{
        setText("insideVal", "Not inside any KML");
        setText("iwbVal", "‚Äî");
        setText("townVal", "‚Äî");
      }

      onTrackPoint(latitude, longitude, accuracy);
    },
    () => { setGpsStatus(false); stopGPS(); },
    { enableHighAccuracy:true, maximumAge: 5000, timeout: 20000 }
  );

  setGpsStatus(true);
}
function stopGPS(){
  if(watchId){ navigator.geolocation.clearWatch(watchId); watchId = null; }
  setGpsStatus(false);
}

/* =========================
   Structure logs + popup
========================= */
let structureLogs = [];
function updateLogStatus(){
  document.getElementById("logStatus").textContent = `Logs: ${structureLogs.length}`;
}
updateLogStatus();

function makeStructurePopup(rec){
  const esc = (s) => String(s ?? "")
    .replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;");
  return `
  <div style="font-family:system-ui; font-size:12px; line-height:1.35; color:#0b1220;">
    <div style="font-weight:900; margin-bottom:6px;">üè† ${esc(rec.structureName || "Structure")}</div>
    <div><b>House/Plot:</b> ${esc(rec.houseNo || "‚Äî")}</div>
    <div><b>Owner:</b> ${esc(rec.ownerName || "‚Äî")}</div>
    <div><b>Households:</b> ${esc(rec.households || "‚Äî")}</div>
    <div><b>Town:</b> ${esc(rec.town || "‚Äî")}</div>
    <div><b>IV/Ward/Block:</b> IV ${esc(rec.iv || "‚Äî")} / W ${esc(rec.ward || "‚Äî")} / B ${esc(rec.block || "‚Äî")}</div>
    <div><b>KML:</b> ${esc(rec.kmlName || "‚Äî")}</div>
    <div><b>GPS:</b> ${rec.lat.toFixed(6)}, ${rec.lng.toFixed(6)} (¬±${rec.acc?Math.round(rec.acc):"?"}m)</div>
    <div style="margin-top:6px"><b>Remarks:</b><br/>${esc(rec.remarks || "‚Äî")}</div>
    <div style="margin-top:6px; color:#475569;"><b>Time:</b> ${new Date(rec.ts).toLocaleString()}</div>
  </div>`;
}

function addStructureAtCurrentLocation(){
  if(!lastPos) return;
  if(!kmlItems.length) return;

  const {lat, lng, acc} = lastPos;
  const hit = findKmlHitForLatLng(lat, lng);
  if(!hit) return;

  const townResolved = boundaryLoaded ? resolveTownForWBIV(hit.iv, hit.ward, hit.block) : "";

  const rec = {
    ts: Date.now(),
    lat, lng, acc: acc || null,
    iv: String(hit.iv||""),
    ward: String(hit.ward||""),
    block: String(hit.block||""),
    kmlName: hit.name,
    town: townResolved || "",
    houseNo: document.getElementById("houseNoInp").value.trim(),
    structureName: document.getElementById("structureNameInp").value.trim(),
    ownerName: document.getElementById("ownerNameInp").value.trim(),
    households: document.getElementById("householdsInp").value.trim(),
    remarks: document.getElementById("remarksInp").value.trim(),
  };

  const m = L.marker([lat,lng]).addTo(structureLayer);
  m.bindPopup(makeStructurePopup(rec));

  structureLogs.push(rec);
  updateLogStatus();
}

/* =========================
   Voice input (Web Speech API)
========================= */
let speechRec = null;
let speechActive = false;
let lastFocusedInput = null;

["houseNoInp","structureNameInp","ownerNameInp","householdsInp","remarksInp"].forEach(id=>{
  const el = document.getElementById(id);
  el.addEventListener("focus", ()=> lastFocusedInput = el);
  el.addEventListener("click", ()=> lastFocusedInput = el);
});

function startVoice(){
  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  if(!SpeechRecognition) return;
  if(speechActive) return;

  speechRec = new SpeechRecognition();
  speechRec.lang = "en-IN";
  speechRec.interimResults = true;
  speechRec.continuous = true;

  speechRec.onstart = () => { speechActive = true; };
  speechRec.onend = () => { speechActive = false; };
  speechRec.onresult = (event) => {
    let finalText = "";
    for(let i = event.resultIndex; i < event.results.length; i++){
      const transcript = event.results[i][0].transcript;
      if(event.results[i].isFinal) finalText += transcript;
    }
    const target = lastFocusedInput || document.getElementById("remarksInp");
    if(finalText.trim()){
      target.value = (target.value ? (target.value.trim() + " ") : "") + finalText.trim();
    }
  };
  speechRec.start();
}
function stopVoice(){ try{ if(speechRec) speechRec.stop(); }catch(e){} }

/* =========================
   Export helpers (CSV + GeoJSON)
========================= */
function downloadBlob(filename, content, mime){
  const blob = new Blob([content], {type: mime});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url; a.download = filename;
  document.body.appendChild(a); a.click(); a.remove();
  URL.revokeObjectURL(url);
}
function exportLogsCSV(){
  if(!structureLogs.length) return;
  const cols = ["ts","time","lat","lng","acc","town","iv","ward","block","kmlName","houseNo","structureName","ownerName","households","remarks"];
  const esc = (v) => {
    const s = String(v ?? "");
    if(/[,"\n\r]/.test(s)) return `"${s.replace(/"/g,'""')}"`;
    return s;
  };
  const lines = [cols.join(",")];
  for(const r of structureLogs){
    const row = { ...r, time: new Date(r.ts).toLocaleString() };
    lines.push(cols.map(c => esc(row[c])).join(","));
  }
  downloadBlob(`ufs_structure_logs_${Date.now()}.csv`, lines.join("\n"), "text/csv;charset=utf-8");
}
function exportLogsGeoJSON(){
  if(!structureLogs.length) return;
  const fc = {
    type: "FeatureCollection",
    features: structureLogs.map(r => ({
      type: "Feature",
      geometry: { type: "Point", coordinates: [r.lng, r.lat] },
      properties: {
        ts: r.ts, time: new Date(r.ts).toISOString(),
        acc: r.acc, town: r.town, iv: r.iv, ward: r.ward, block: r.block,
        kmlName: r.kmlName, houseNo: r.houseNo, structureName: r.structureName,
        ownerName: r.ownerName, households: r.households, remarks: r.remarks
      }
    }))
  };
  downloadBlob(`ufs_structure_logs_${Date.now()}.geojson`, JSON.stringify(fc, null, 2), "application/geo+json");
}
function clearLogs(){
  structureLogs = [];
  structureLayer.clearLayers();
  updateLogStatus();
}

/* =========================
   Fit/Clear map
========================= */
function fitAll(){
  const layers = [];
  boundaryLayer.getLayers().forEach(l => layers.push(l));
  structureLayer.getLayers().forEach(l => layers.push(l));
  if(trackLine) layers.push(trackLine);
  if(layers.length){
    const fg = L.featureGroup(layers);
    try{ map.fitBounds(fg.getBounds().pad(0.15)); }catch(e){}
  }
}
function clearAll(){
  boundaryLayer.clearLayers();
  structureLayer.clearLayers();
  kmlItems.length = 0;
  updateCount();
  if(trackLine){ try{ map.removeLayer(trackLine); }catch(e){} }
  trackLine = null; trackPts = [];
  setText("insideVal","‚Äî"); setText("iwbVal","‚Äî"); setText("townVal","‚Äî");
}

/* =========================
   Persist prefs (shared)
========================= */
const LS_PROXY="ufs_proxyUrl", LS_DRIVE="ufs_driveUrl", LS_AUTOFETCH="ufs_autoFetch", LS_BOUND="ufs_boundaryUrl";
function loadPrefs(){
  const p = localStorage.getItem(LS_PROXY); if(p) document.getElementById("proxyUrl").value = p;
  const d = localStorage.getItem(LS_DRIVE); if(d) document.getElementById("kmlUrl").value = d;
  const a = localStorage.getItem(LS_AUTOFETCH); if(a) document.getElementById("autoFetchChk").checked = (a==="1");
  const b = localStorage.getItem(LS_BOUND); if(b) document.getElementById("boundaryUrl").value = b;
}
function savePrefs(){
  localStorage.setItem(LS_PROXY, document.getElementById("proxyUrl").value.trim());
  localStorage.setItem(LS_DRIVE, document.getElementById("kmlUrl").value.trim());
  localStorage.setItem(LS_AUTOFETCH, document.getElementById("autoFetchChk").checked ? "1":"0");
  localStorage.setItem(LS_BOUND, document.getElementById("boundaryUrl").value.trim());
}

/* =========================
   Events
========================= */
document.getElementById("kmlInput").addEventListener("change", async (e) => { await handleKmlOrZipFiles(e.target.files); e.target.value=""; });
document.getElementById("boundaryInput").addEventListener("change", async (e) => {
  const f = e.target.files && e.target.files[0]; if(!f) return;
  const txt = await f.text(); loadBoundaryFromCSVText(txt);
  e.target.value="";
});

document.getElementById("fetchDriveBtn").addEventListener("click", async () => { savePrefs(); await fetchDriveZip(); });
document.getElementById("loadKmlUrlBtn").addEventListener("click", async () => { savePrefs(); await loadNonDriveUrl(); });

document.getElementById("restoreSavedBtn").addEventListener("click", restoreSaved);
document.getElementById("clearSavedBtn").addEventListener("click", clearSaved);

document.getElementById("loadBoundaryBtn").addEventListener("click", async () => { savePrefs(); await loadBoundaryFromUrlOrSheet(); });

document.getElementById("startGpsBtn").addEventListener("click", startGPS);
document.getElementById("stopGpsBtn").addEventListener("click", stopGPS);

document.getElementById("toggleTrackBtn").addEventListener("click", toggleTrack);

document.getElementById("addStructureBtn").addEventListener("click", addStructureAtCurrentLocation);
document.getElementById("voiceBtn").addEventListener("click", startVoice);
document.getElementById("stopVoiceBtn").addEventListener("click", stopVoice);
document.getElementById("exportCsvBtn").addEventListener("click", exportLogsCSV);
document.getElementById("exportGeoJsonBtn").addEventListener("click", exportLogsGeoJSON);
document.getElementById("clearLogsBtn").addEventListener("click", clearLogs);

document.getElementById("fitAllBtn").addEventListener("click", fitAll);
document.getElementById("clearBtn").addEventListener("click", clearAll);

["proxyUrl","kmlUrl","autoFetchChk","boundaryUrl"].forEach(id=>{
  document.getElementById(id).addEventListener("change", savePrefs);
});

/* =========================
   Init
========================= */
function init(){
  setGpsStatus(false);
  setBoundaryStatus(false, "Boundary: NOT LOADED");
  loadPrefs();
  restoreSaved();
}
init();

(async () => {
  if(document.getElementById("autoFetchChk").checked){
    const link = document.getElementById("kmlUrl").value.trim();
    const proxy = document.getElementById("proxyUrl").value.trim();
    if(link && proxy){
      try{ await fetchDriveZip(); }catch(e){}
    }
  }
})();
</script>
</body>
</html>